<!DOCTYPE html>
<html>
<head>
    <title>Pomfret School - Enhanced Building Shape Extractor</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        body { margin: 0; padding: 0; font-family: Arial, sans-serif; }
        #map { height: 70vh; width: 100%; }
        #controls { padding: 20px; background: #f5f5f5; }
        #output { margin-top: 20px; padding: 20px; background: white; border: 1px solid #ddd; }
        button { padding: 10px 20px; font-size: 16px; cursor: pointer;
                 background: #2c5aa0; color: white; border: none; border-radius: 4px; margin: 5px; }
        button:hover { background: #1a3a6f; }
        pre { background: #f8f8f8; padding: 15px; overflow-x: auto; max-height: 400px;
              font-size: 11px; line-height: 1.4; }
        .info { color: #666; margin-top: 10px; }
        .success { color: #27ae60; font-weight: bold; }
        .error { color: #e74c3c; font-weight: bold; }
        .stats { background: #e8f4f8; padding: 10px; margin: 10px 0; border-radius: 4px; }
        .building-item { padding: 5px; margin: 2px 0; background: #fafafa; border-left: 3px solid #2c5aa0; }
    </style>
</head>
<body>
    <div id="controls">
        <h2>Enhanced Building Shape Extractor - Pomfret School</h2>
        <p>Extracts FULL building geometry with all points, curves, and complex shapes (not simplified boxes).</p>
        <button onclick="fetchDetailedBuildings()">Extract Detailed Building Shapes</button>
        <button onclick="fetchBuildingsWithRelations()">Include Building Relations (Courtyards, Wings)</button>
        <div class="info">
            <strong>Note:</strong> This extracts complete building geometries with ALL coordinate points,
            preserving L-shapes, courtyards, wings, and architectural complexity.
        </div>
    </div>

    <div id="map"></div>

    <div id="output"></div>

    <script>
        // Initialize map centered on Pomfret School
        const map = L.map('map').setView([41.8862, -71.9640], 17);

        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
            attribution: '© OpenStreetMap'
        }).addTo(map);

        // Draw campus bounding box
        const bounds = [
            [41.8795, -71.9710],  // Southwest
            [41.8930, -71.9570]   // Northeast
        ];

        L.rectangle(bounds, {
            color: '#2c5aa0',
            weight: 2,
            fillOpacity: 0.1
        }).addTo(map);

        L.marker([41.8862, -71.9640]).addTo(map)
            .bindPopup('Pomfret School Campus Center');

        async function fetchDetailedBuildings() {
            const output = document.getElementById('output');
            output.innerHTML = '<p>Fetching detailed building geometries from OpenStreetMap...</p>';

            // Overpass API query - gets ALL nodes for each building way
            const query = `
                [out:json][timeout:25];
                (
                  way["building"](41.8795,-71.9710,41.8930,-71.9570);
                  relation["building"](41.8795,-71.9710,41.8930,-71.9570);
                );
                out body;
                >;
                out skel qt;
            `;

            try {
                const response = await fetch('https://overpass-api.de/api/interpreter', {
                    method: 'POST',
                    body: query
                });

                const data = await response.json();
                const buildings = processDetailedBuildings(data);
                displayDetailedResults(buildings);

            } catch (error) {
                output.innerHTML = `<p class="error">Error: ${error.message}</p>`;
            }
        }

        async function fetchBuildingsWithRelations() {
            const output = document.getElementById('output');
            output.innerHTML = '<p>Fetching buildings with multipolygon relations (complex structures)...</p>';

            // Enhanced query for building relations (multipart buildings)
            const query = `
                [out:json][timeout:25];
                (
                  way["building"](41.8795,-71.9710,41.8930,-71.9570);
                  relation["building"](41.8795,-71.9710,41.8930,-71.9570);
                  relation["type"="multipolygon"]["building"](41.8795,-71.9710,41.8930,-71.9570);
                );
                out body;
                >;
                out skel qt;
            `;

            try {
                const response = await fetch('https://overpass-api.de/api/interpreter', {
                    method: 'POST',
                    body: query
                });

                const data = await response.json();
                const buildings = processDetailedBuildings(data, true);
                displayDetailedResults(buildings);

            } catch (error) {
                output.innerHTML = `<p class="error">Error: ${error.message}</p>`;
            }
        }

        function processDetailedBuildings(data, includeRelations = false) {
            const nodes = {};
            const buildings = [];

            // First pass: store all nodes with coordinates
            data.elements.forEach(el => {
                if (el.type === 'node') {
                    nodes[el.id] = { lat: el.lat, lon: el.lon };
                }
            });

            // Second pass: process building ways with FULL geometry
            data.elements.forEach(el => {
                if (el.type === 'way' && el.tags && el.tags.building) {
                    const coords = el.nodes
                        .map(nodeId => nodes[nodeId])
                        .filter(n => n);

                    if (coords.length > 0) {
                        const building = {
                            id: el.id,
                            type: 'way',
                            name: el.tags.name || null,
                            buildingType: el.tags.building,
                            coordinates: coords.map(n => [n.lon, n.lat]),
                            pointCount: coords.length,  // Track complexity
                            height: el.tags.height || null,
                            levels: el.tags['building:levels'] || el.tags.levels || null,
                            roof_shape: el.tags['roof:shape'] || null,
                            amenity: el.tags.amenity || null,
                            tags: el.tags
                        };

                        // Calculate approximate area
                        building.area = calculatePolygonArea(building.coordinates);

                        buildings.push(building);
                    }
                }

                // Process building relations (multipolygon buildings with courtyards)
                if (includeRelations && el.type === 'relation' && el.tags && el.tags.building) {
                    buildings.push({
                        id: el.id,
                        type: 'relation',
                        name: el.tags.name || null,
                        buildingType: el.tags.building,
                        members: el.members,
                        tags: el.tags,
                        note: 'Multipolygon building (may have inner courtyards or multiple parts)'
                    });
                }
            });

            return buildings;
        }

        function calculatePolygonArea(coords) {
            // Shoelace formula for polygon area
            let area = 0;
            for (let i = 0; i < coords.length - 1; i++) {
                area += coords[i][0] * coords[i + 1][1];
                area -= coords[i + 1][0] * coords[i][1];
            }
            return Math.abs(area / 2);
        }

        function displayDetailedResults(buildings) {
            const output = document.getElementById('output');

            // Sort by area (largest first)
            buildings.sort((a, b) => (b.area || 0) - (a.area || 0));

            const named = buildings.filter(b => b.name);
            const complex = buildings.filter(b => b.pointCount > 8);  // More than 8 points = complex shape
            const relations = buildings.filter(b => b.type === 'relation');

            let html = `
                <h3 class="success">✓ Successfully extracted ${buildings.length} buildings</h3>
                <div class="stats">
                    <strong>${named.length}</strong> named buildings<br>
                    <strong>${complex.length}</strong> buildings with complex shapes (>8 points)<br>
                    <strong>${relations.length}</strong> multipolygon relations (courtyards/wings)<br>
                </div>

                <h4>Named Buildings (by size):</h4>
            `;

            named.forEach(b => {
                const complexity = b.pointCount ? `${b.pointCount} points` : 'relation';
                const areaStr = b.area ? `${(b.area * 1000000).toFixed(0)} m²` : 'N/A';
                html += `
                    <div class="building-item">
                        <strong>${b.name}</strong> - ${complexity}, ~${areaStr}
                        ${b.height ? `, ${b.height}` : ''}
                        ${b.levels ? `, ${b.levels} levels` : ''}
                    </div>
                `;
            });

            html += `
                <h4>Complex Buildings (detailed shapes):</h4>
                <div class="info">Buildings with 9+ coordinate points (L-shapes, courtyards, wings)</div>
            `;

            complex.slice(0, 10).forEach(b => {
                html += `
                    <div class="building-item">
                        ${b.name || 'Unnamed'} - <strong>${b.pointCount} points</strong>
                        (ID: ${b.id})
                    </div>
                `;
            });

            html += `
                <h4>JavaScript Data (Ready for Turtletoy):</h4>
                <button onclick="downloadAsJSON()">Download as JSON</button>
                <button onclick="downloadAsTurtletoy()">Generate Turtletoy Code</button>
                <pre id="fullData">${JSON.stringify(buildings, null, 2)}</pre>
            `;

            output.innerHTML = html;

            // Store data globally
            window.buildingData = buildings;

            // Draw buildings on map with color coding
            buildings.forEach(b => {
                if (b.coordinates && b.coordinates.length > 2) {
                    const coords = b.coordinates.map(c => [c[1], c[0]]);

                    // Color by complexity
                    let color = '#3498db';  // Simple
                    if (b.pointCount > 15) color = '#e74c3c';  // Very complex
                    else if (b.pointCount > 8) color = '#f39c12';  // Complex
                    if (b.name) color = '#27ae60';  // Named

                    const polygon = L.polygon(coords, {
                        color: color,
                        weight: 2,
                        fillOpacity: 0.3
                    }).addTo(map);

                    polygon.bindPopup(
                        `<strong>${b.name || 'Unnamed'}</strong><br>` +
                        `Type: ${b.buildingType}<br>` +
                        `Points: ${b.pointCount}<br>` +
                        `Area: ~${(b.area * 1000000).toFixed(0)} m²<br>` +
                        `ID: ${b.id}`
                    );
                }
            });
        }

        function downloadAsJSON() {
            const dataStr = JSON.stringify(window.buildingData, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'pomfret_buildings_detailed.json';
            a.click();
        }

        function downloadAsTurtletoy() {
            // Generate Turtletoy code with detailed shapes
            const buildings = window.buildingData.filter(b => b.coordinates && b.name);

            let code = '// Pomfret School - Detailed Building Shapes\n';
            code += '// Extracted from OpenStreetMap with full geometry\n\n';

            code += 'const buildings = [\n';
            buildings.forEach((b, i) => {
                code += `  // ${b.name} (${b.pointCount} points)\n`;
                code += '  [';
                b.coordinates.forEach((coord, j) => {
                    if (j > 0) code += ',';
                    if (j % 3 === 0) code += '\n    ';
                    code += `[${coord[0].toFixed(7)},${coord[1].toFixed(7)}]`;
                });
                code += '\n  ]' + (i < buildings.length - 1 ? ',' : '') + '\n';
            });
            code += '];\n';

            const blob = new Blob([code], { type: 'text/javascript' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'pomfret_buildings_turtletoy.js';
            a.click();
        }
    </script>
</body>
</html>
